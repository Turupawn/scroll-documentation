---
section: sdk
date: Last Modified
title: "Running Scroll SDK Devnet"
lang: "en"
permalink: "sdk/guides/devnet-deploymnet"
excerpt: "Run the Scroll SDK devnet locally to get started."
---

import Aside from "../../../../../components/Aside.astro"
import ToggleElement from "../../../../../components/ToggleElement.astro"
import Steps from '../../../../../components/Steps/Steps.astro';


## Overview

This guide should get you started with running a local Scroll SDK devnet. Additionally, it has specific asides for running is on macos.

This guide assumes you have access to the [scroll-sdk github repo](https://github.com/scroll-tech/scroll-sdk) using your local machine.

We’ve written this guide because local deployments for Kubernetes clusters can be finicky.

By the end of the guide, you should have a Scroll SDK running with a block explorer, RPC, webUI, monitoring and metrics, and a local L1. These are all accessible to wallets, browsers, and applications running on your local machine.

<Aside type="caution">
This guide assumes the user is using macos. Windows is not supported, and Linux flavors might require modifications.
</Aside>

<Aside type="caution">
This guide does not include running the coordinator or a prover. The coordinator currently requires 20GB of RAM to run, so we disable it by default, and provers need dedicated machines to run and require additional configuration.
</Aside>

<ToggleElement anchor="Guide Updates">
  <div slot="title">Updates to the Guide</div>
  <span>

  - August 26, 2024
    - Changes for repository refactor, including new CLI tool commands.
  - July 31, 2024
    - Adding additional `make` commands and `minikube` config
  - June 26, 2024
    - Minor typography fixes i.e. `docker v` to `docker -v`
  - June 19, 2024
    - Removed external `bjw-s` dependency and prerequisite
    - Removed manual modification of `.env.frontends`
    - Updated docker image name used in generating config files
  - June 18, 2024
    - Fixed `minikube addons enable` commands (missing “addons”)

  </span>
</ToggleElement>

## Prerequisites
<Steps>
1. Install dependencies (using `brew` is strongly recommended):
    - [Brew](https://brew.sh/) (optional)
      - `/bin/bash -c "$(curl -fsSL [https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh](https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh))"`
    - Docker ([Docker Desktop](https://docs.docker.com/desktop/install/mac-install/))
      - `brew install --cask docker`
    - [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/)
      - `brew install kubectl`
    - [minikube](https://minikube.sigs.k8s.io/docs/start/?arch=%2Fmacos%2Farm64%2Fstable%2Fhomebrew)
      - `brew install minikube`
    - [Helm](https://helm.sh/docs/intro/install/#from-homebrew-macos)
      - `brew install helm`
    - [docker-mac-net-connect](https://github.com/chipmk/docker-mac-net-connect) (macOS ARM64 only)
      - `brew install chipmk/tap/docker-mac-net-connect`
2. *Optional:* Install dependencies for support CLI tool:
    - [node >=18](https://nodejs.org/en/download/package-manager)
      - `brew install nvm`
      - `nvm install node`
    - scroll-sdk-cli *(Experimental, APIs may change)*
      - `npm install -g scroll-sdk-cli`
3. You should now be able to open a terminal and run the following:
    - `docker -v`
    - `kubectl version`
    - `minikube status`
    - `helm version`
    - `node -v`
    - `scrollsdk`
    - Or, in one step: `scrollsdk test dependencies`

</Steps>

<Aside type="tip" note="Setting Default Resources for `minikube`">
By default, minikube is allocated 2 CPU and 4GB RAM. For best performance, you can set higher resource limits before starting minikube.

```bash
minikube config set cpus 8
minikube config set memory 8192
```

</Aside>

### Starting minikube

To start minikube, run:

```bash
minikube start --driver=docker
minikube addons enable ingress
minikube addons enable ingress-dns
```

#### Getting minikube to work with custom DNS names on MacOS

Now run the following commands:

```bash
minikube ssh "sudo apt-get update && sudo apt-get -y install qemu-user-static"
minikube addons enable ingress
minikube addons enable ingress-dns
sudo brew services start chipmk/tap/docker-mac-net-connect
```

<Aside type="danger" title="This is a hack!">
These are all a work-around for ingress-dns not working on arm64 MacOS and hopefully will change in later fixes to minikube. This work gets relied on in [Pointing DNS Requests to the Cluster](#pointing-dns-requests-to-the-cluster).
</Aside>

## Installing Scroll SDK

<Aside type="caution">
To grab charts from the private repo, you'll need to setup a legacy GitHub [personal access token](https://github.com/settings/tokens) with read access to the repo.

Then, set it as a env var and run: `echo $GHCR_PAT | docker login ghcr.io -u [github username] --password-stdin`
</Aside>


<Steps>
1. **Clone the `scroll-sdk` repo and find `devnet` directory**

    *You’ll need If you need repo access, reach out to `@dghelm` on Telegram.*

    ```bash
    git clone git@github.com:scroll-tech/scroll-sdk.git
    cd scroll-sdk/devnet
    ```

1. **Bootstrap**

    Now we'll install Helm chart dependencies, generate additional config files for our services, and create our `genesis.json` file.

    ```bash
    make bootstrap
    ```

    <Aside note="caution" title="Command changes frequently!">
    The behavior of this command can change frequently since it refers to a specific docker image. Be sure to keep your repo up to date.
    </Aside>

1. Optional: **Configure `values.yaml` and `config.toml`**

    This is the time to adjust what services run on your stack and their configuration. I’d suggest not altering these on your first installation, but see `charts/scroll-sdk/values.yaml` ([view on Github](https://github.com/scroll-tech/scroll-sdk/blob/develop/charts/scroll-sdk/values.yaml)) and `config.toml` ([view on Github](https://github.com/scroll-tech/scroll-sdk/blob/develop/charts/scroll-sdk/config.toml)).

    If you do make changes, you’ll need to run `make config` to regenerate the additional configuration files.


1. **Launch the chain!**

    ```bash
    make install
    ```

    Your chain is now starting! Run `kubectl get pods` to check in on their progress. In the next section we’ll expose the chain to your local machine so you can interact with the stack.

    <Aside>
    The whole start process for the various containers can take up to  minutes.
    </Aside>
</Steps>

<Aside>
In Devnet, we'll work inside the `scroll-sdk` repo folder. This is not the recommended method for production deployments.
</Aside>

## After Launching the Stack

### Funding SDK Addresses

You will need to provide funds to the following accounts:

  - `DEPLOYER_ADDR` *(only needs funded on L1)*
    - In the default configuration, this account is pre-funded by Anvil. If changed, you'll need to relaunch the contracts pod after funding to deploy the contracts.
  - `L1_COMMIT_SENDER_ADDR`
  - `L1_FINALIZE_SENDER_ADDR`
  - `L1_GAS_ORACLE_SENDER_ADDR`
  - `L2_GAS_ORACLE_SENDER_ADDR` *(funded after L2 chain deployment)*

If you installed the necessary prerequisites, you can run the cli helper command after [Pointing DNS Requests to the Cluster](#pointing-dns-requests-to-the-cluster-macos-on-arm64). (Note: this command only works for L1 accounts)

```bash
cd scroll-sdk
scrollsdk helper fund-accounts --dev
```

### Other Useful Commands

`kubectl get pods` will show all the active pods and their status.

`kubectl get ingress` will show all the exposed services and URIs.

`make delete` will stop all services. You wil also need to run `kubectl delete pvc data-l2-rpc-0` to delete the remaining pvc.

`minikube dashboard` launches a WebUI for exploring the kubernetes cluster and the various pods, volumes and ingresses without learning all the CLI commands. `k9s` is also a CLI great tool for exploring running pods and quickly looking at their logs.

If you need to update a specific service's config file:
  1. Make any necessary changes to the config or helm charts
  2. Run `make install`
  3. Delete the running pod by running `kubectl delete pod [pod-name]`

### Pointing DNS Requests to the Cluster (MacOS on ARM64)

Running `kubectl get ingress` should show all the domains setup within the cluster, like the following:

```
➜  scroll-sdk git:(develop) ✗ kubectl get ingress
NAME                      CLASS   HOSTS                               ADDRESS        PORTS   AGE
admin-system-dashboard    nginx   admin-system-dashboard.scrollsdk    192.168.49.2   80      5h3m
blockscout                nginx   blockscout.scrollsdk                192.168.49.2   80      5h3m
bridge-history-api        nginx   bridge-history-api.scrollsdk        192.168.49.2   80      5h3m
frontends                 nginx   frontends.scrollsdk                 192.168.49.2   80      5h3m
grafana                   nginx   grafana.scrollsdk                   192.168.49.2   80      5h3m
l1-devnet                 nginx   l1-devnet.scrollsdk                 192.168.49.2   80      5h3m
l1-explorer               nginx   l1-devnet-explorer.scrollsdk        192.168.49.2   80      5h3m
l2-rpc                    nginx   l2-rpc.scrollsdk                    192.168.49.2   80      5h3m
l2-rpc-websocket          nginx   l2-rpc-ws.scrollsdk                 192.168.49.2   80      5h3m
rollup-explorer-backend   nginx   rollup-explorer-backend.scrollsdk   192.168.49.2   80      5h3m
```

Now, we’ll follow the instructions from [the minikube docs](https://minikube.sigs.k8s.io/docs/handbook/addons/ingress-dns/#Mac) for setting up our local machine to use our cluster to resolve all `.scrollsdk` domain requests.

Take note of the `ADDRESS` in your output (it should match the result of running `minikube ip`).

You’ll want to create the following file at `/etc/resolver/minikube-scrollsdk` (will require `sudo` access).

```
domain scrollsdk
nameserver <minikube_ip>
search_order 1
timeout 5
```

If you prefer, this can be done in one command that creates the directory and file and then outputs the required info:

```bash
sudo mkdir -p /etc/resolver && sudo touch /etc/resolver/minikube-scrollsdk && sudo sudo sh -c "cat >>/etc/resolver/minikube-scrollsdk" <<-EOF

	domain scrollsdk
	nameserver $(minikube ip)
	search_order 1
	timeout 5
EOF
```

Lastly, flush your DNS:

```bash
sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder
```

#### Testing Ingress DNS

Try running:

1.  `nslookup frontends.scrollsdk $(minikube ip)`
2.  `curl frontends.scrollsdk`
3.  If those work, visit [`http://frontends.scrollsdk`](http://frontends.scrollsdk) in your browser.
    1. If those do not work, try resetting your machine and running through the instructions in [Getting minikube to work with custom DNS names on MacOS](https://www.notion.so/Getting-minikube-to-work-with-custom-DNS-names-on-MacOS-e40ae30777ec4dd083e71d37ead1a185?pvs=21) and above again. It may help to run `minikube stop` and `minikube start` again.

## Testing & Interacting with the Chain

### scroll-sdk-CLI

The scroll-sdk-cli tool has many helper commands. Run it in the same directory as your `config.toml` file in the `./devnet/scroll-sdk` folder.

- `scrollsdk test ingress` will test if your ingress is configured correctly and host urls are accessible from your machine.
- `scrollsdk test contracts` will check that essential contracts are deployed, initialized and have the correct owner.
- `scrollsdk helper fund-accounts --dev -a [account-address]` will fund any account.
- `scrollsdk helper activity -o -t` will generate activity on both layer one and layer two to help produce blocks and batches.

#### End-To-End Test

The `scrollsdk test e2e` command will walk you through generating the following tests on your chain:

- Generate a new wallet
- Fund it from the Deployer address on L1
- Deposit funds to the L2
- Deploying an ERC20 and depositing them to the L2
- Deploying an ERC20 on the L2
- Bridging ETH and ERC20 from L2 back to L1
- Executing the withdrawal claim on L1

If any step fails, you can restart where you left off by adding the `--resume` flag.

<Aside>
We recommend running `scrollsdk helper activity` in another terminal to generate traffic on the chain while running the end-to-end test. This will keep blocks being produced, which is needed for bridging transactions, gas oracle updates and batch submission and finalization.
</Aside>


### Web UIs

You should now be able to explore the stack on your local machine and using your web browser. All links below assume default configuration and working Ingress DNS.

- Block Explorers (Blockscout)
  - [L2 Explorer](http://blockscout.scrollsdk/)
  - [L1 Explorer](http://l1-devnet-explorer.scrollsdk/) (this is scanning Anvil and can be a bit buggy)
- [Bridge](http://frontends.scrollsdk/bridge)
  - Until some activity on the network has started, gas errors may occur.
- [Rollup Explorer](http://frontends.scrollsdk/rollupscan?page=1&per_page=10)
  - Shows committed batches and finalized batches
- [Granfana Dashboards](http://grafana.scrollsdk/)
  - Login
    - User: `admin`
    - Pass: `scroll-sdk`
  - See “Scroll” dashboards on [this page](http://grafana.scrollsdk/dashboards).

### Connecting to the RPC using a Wallet

To connect directly to an RPC or using MetaMask, use:

| Network | Scroll SDK Chain | Scroll SDK L1 |
|-------------|-------------|-------------|
| RPC URL | `http://l2-rpc.scrollsdk` | `http://l1-devnet.scrollsdk` |
| Chain ID | `221122` | `111111` |
| Currency Symbol | `ETH` | `ETH` |
| Block Explorer URL | [`http://blockscout.scrollsdk`](http://blockscout.scrollsdk/) | [`http://l1-devnet-explorer.scrollsdk`](http://l1-devnet-explorer.scrollsdk/) |

<Aside type="caution">
Until we setup `https` you need to manually set these up in MetaMask and the WebUI buttons will not work.
</Aside>

### Helpful Commands

Anvil has a lot of [useful methods](https://book.getfoundry.sh/reference/anvil/#custom-methods) that can manipulate the L1. Proper documentation for using them is available in the [Hardhat docs](https://hardhat.org/hardhat-network/docs/reference#hardhat-network-methods) (replacing `hardhat_` with `anvil_`)

#### Set L1 Token Balance of an Account

In params, change first item to a wallet, and second to hex of wei. This config uses 1000 ETH.

See [docs](https://hardhat.org/hardhat-network/docs/reference#hardhat_setbalance) for details.

```bash
curl --location 'http://l1-devnet.scrollsdk/' \
--header 'Content-Type: application/json' \
--data '{
	"jsonrpc":"2.0",
	"method":"anvil_setBalance",
	"params":["0x98110937b5D6C5FCB0BA99480e585D2364e9809C","0x3635C9ADC5DEA00000"],
	"id":0
}'
```

#### Mine some L1 Block

See [docs](https://hardhat.org/hardhat-network/docs/reference#hardhat_mine) for details.

```bash
curl --location 'http://l1-devnet.scrollsdk/' \
--header 'Content-Type: application/json' \
--data '{
	"jsonrpc":"2.0",
	"method":"anvil_mine",
	"params":["0x10000000", "0xc"],
	"id":0
}'
```

## Troubleshooting

### `ingress-dns` issues

Getting `ingress-dns` can be tricky across different machines, operating systems and network configurations. 

**Directly editing `etc/hosts` has worked for some users, adding all ingress hosts pointing to the minikube IP address.**

Follow the template below, being sure to create one value for every ingress in your configuration. Also, be sure to try the IP of your minikube deployment.

For VPN users, we've seen the following work:

<Steps>
1. Execute command `sudo minikube tunnel`

1. Open file `/etc/hosts` and add:
    ```
    127.0.0.1 l1-devnet.scrollsdk
    127.0.0.1 bridge-history.scrollsdk
    127.0.0.1 frontends.scrollsdk
    127.0.0.1 grafana.scrollsdk
    127.0.0.1 l1-devnet-explorer.scrollsdk
    127.0.0.1 l2-rpc.scrollsdk
    127.0.0.1 blockscout.scrollsdk
    127.0.0.1 bridge-history-api.scrollsdk
    ```

1. Turn off VPN when visiting in browser
</Steps>